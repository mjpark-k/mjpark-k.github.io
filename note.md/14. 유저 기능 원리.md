# 유저 기능 원리

## 🍪 쿠키 보안

> 쿠키 🍪  
> 서버 리스폰스나, 클라이언트 코드에 따라 브라우저에 저장되는 작은 단위의 문자열 파일들

쿠키는 유저 인증뿐만 아니라, 브라우저 이용자에 대한 개인화된 기능과 데이터 제공 수단으로 사용할 수 있습니다.

로그인을 하지 않아도 검색 기록이 저장되거나, 쇼핑 카트를 사용할 수 있다거나, 한 번 설정한 라이트와 다크 테마도 유지되는 경우들이 많잖아요? 이런 걸 쿠키를 통해 할 수 있죠.

하지만 브라우저 사용자가 아닌 다른 사람이 쿠키를 가로채거나 여러 방법들로 악용한다면, 보안 문제가 생길 수 있습니다. 특히 인증 관련 쿠키가 악용된다면 큰 문제로 이어질 수 있는데요.

이번 레슨에서는 쿠키 인증을 사용할 때 보안 문제를 줄일 수 있는 설정들에 대해서 알아보겠습니다.

(리스폰스 쿠키 설정 예시)
![](https://velog.velcdn.com/images/pmj9498/post/5e9edb37-e1c4-42ba-b6b8-d2cd361fe0cd/image.png)

### Secure

첫 번째는 Secure 설정입니다. 서버에서 리스폰스를 보낼 때 이 설정을 추가해 주면 HTTP보다 보안에 강한 HTTPS를 사용할 때만 클라이언트에서 서버로 쿠키가 보내집니다. HTTPS를 사용하면 항상 리퀘스트와 리스폰스가 암호화되기 때문에 누군가 중간에 리퀘스트를 가로챘을 때 정보 유출을 줄일 수 있습니다.

Secure 설정은 리스폰스 Set-Cookie 헤더에 이름-값 쌍 뒤 `;`과 `Secure` 키워드를 사용해서 적용할 수 있습니다.

```
Set-Cookie: cookie_name=cookie_value; Secure;
```

### HttpOnly

두 번째는 HttpOnly입니다. 이 설정을 추가하면 클라이언트가 자바스크립트 코드로 해당 쿠키에 접근할 수 없게 됩니다. 자바스크립트 코드로는 가지고 올 수 없고, 그냥 쿠키를 설정한 웹사이트에 리퀘스트로 보낼 수만 있는 거죠. 코드로 쿠키에 접근할 수 없으면, 악의적 클라이언트가 개인 정보에 직접 접근하는 걸 막을 수 있습니다. 하지만 때에 따라서 코드로 저장한 쿠키에 접근하고 싶을 수 있으니까요. 이 설정은 필요에 따라서 사용하시면 됩니다.

HttpOnly 설정은 리스폰스 Set-Cookie 헤더에 이름-값 쌍 뒤 `;` 과 `HttpOnly` 키워드를 사용해서 적용할 수 있습니다. (Secure와 HttpOnly 설정이 동시에 적용된 예시)

```
Set-Cookie: cookie_name=cookie_value; Secure; HttpOnly;
```

### SameSite

세 번째는 SameSite입니다. 이 설정은 Cross Site Request Forgery의 약자, CSRF(또는 XSRF)라는 공격을 예방할 수 있는 설정입니다.

> **CSRF**는 일반 사이트 A와 악의적 사이트 B가 있을 때, B 웹 페이지에서 브라우저에 저장된 쿠키를 가지고 사이트 A 서버로 리퀘스트를 보내는 공격인데요. 조금 복잡하기 때문에 예시를 사용해서 볼게요.

페이스북이 쿠키를 사용해서 유저 인증을 한다고 가정합시다.

로그인을 하면 브라우저 쿠키에 인증서가 저장돼있을 텐데요. 같은 사용자가 실수로 악의적인 사이트, changeyourpassword.com에 방문했다고 할게요. 이 사이트 안에는 단순히 클릭하는 것만으로 페이스북 비밀번호가 바뀌어버리는 리퀘스트를 보내는 버튼이 있습니다. 문제는 이 리퀘스트를 페이스북에 보내기 때문에 브라우저에 저장된 인증서 쿠키가 같이 가버리는데요. 2단계 인증을 하지 않는다면, 이걸 받은 페이스북은 해당 리퀘스트를 인증서에 나온 유저가 보냈다고 생각하게 됩니다. 유저가 모르는 사이에 비밀번호가 바뀌어버릴 수도 있는 거죠.

SameSite 설정을 사용하면 이 문제를 예방할 수 있습니다.

SameSite를 Strict로 하면 다른 도메인에서 리퀘스트를 보낼 때 쿠키가 가는 걸 아예 방지할 수 있습니다. 이해하기 쉽게 얘기하면 리퀘스트를 보내는 클라이언트와 이걸 받는 서버의 도메인이 서로 같을 때만 쿠키가 갑니다. changeyourpassword.com이란 페이지에서 facebook.com으로 리퀘스트를 보낼 때는 가지 않죠.

하지만 저희는 URL을 직접 쳐서 사이트를 방문하기도 하지만, 이메일이나, 메시지, 심지어 다른 페이지에 있는 링크를 통해서도 페이지를 방문하는데요. 이때도 쿠키가 가지 않는 문제가 생깁니다. 그러니까 URL에 직접 facebook.com을 치면 저장돼있던 쿠키가 가지만, 친구가 메시지로 보낸 링크를 통해서 페이지를 방문할 때는 쿠키가 가지 않아서 다시 로그인을 해야 되죠. 물론 보안을 위해서 이렇게 되길 원하면 상관없지만, 인증 정보처럼 민감한 정보가 아닐 때는 꽤 과한 조치일 수 있는데요.

이때 사용하는 설정이 Lax입니다. Lax는 영어로 느슨한이라는 뜻인데요. 이 설정을 하면 링크를 통해 사이트를 직접 방문할 때는 쿠키가 보내집니다. 예를 들어 코드잇 사이트가 페이스북에 있는 사진을 가지고 와서 코드잇 페이지에 보여주려고 할 때는 쿠키가 가지 않지만, 코드잇에 있는 링크를 통해서 유저가 직접 페이스북 페이지를 방문할 때는 쿠키가 보내지는 거죠.

SameSite 설정을 None으로 하면 아무런 제한 없이 브라우저에서 보내는 모든 리퀘스트에 쿠키가 붙어서 갑니다. SameSite 설정을 None로 할 때는 보안 문제 때문에 항상 Secure 설정을 추가해야 합니다. 추가하지 않으면 특정 브라우저들은 보안이 취약하다고 판단하고 쿠키를 저장하지 않습니다.

SameSite 설정은 리스폰스 Set-Cookie 헤더에 이름-값 쌍 뒤 `;`과 `SameSite` 키워드, 그리고 원하는 쿠키 사용 범위 키워드, None, Lax, Strict를 사용해서 적용할 수 있습니다. (Secure, HttpOnly, 그리고 SameSite=Lax 설정이 동시에 적용된 예시)

```
Set-Cookie: cookie_name=cookie_value; Secure; HttpOnly; SameSite=Lax;
```

## 🔑 Authorization 헤더 인증

```http
DELETE http://example.com/comments/1/
Authorization: 1a2b3c
```

### 장점

- 리퀘스트에 인증서를 붙일지 안 붙일지 선택 가능
- 서로 다른 루트 도메인 사이 인증 가능

### 유의해야될 점

- 비밀번호 같이 민감한 정보는 쿠키나 로컬 스토리지에 절대 저장하지 않는다.

## 🔑 세션 기반 인증

세션이란?  
서버가 저장하는 사이트 방문자들에 대한 기록

## 🔑 토큰 기반 인증 (🔥중요! JWT(JSON Web Token)와 관련)

인증 토큰은 유저에 대한 정보를 암호화한 문자열

![](https://velog.velcdn.com/images/pmj9498/post/6ddc5281-e364-43f8-b1c8-e0eadea7374d/image.png)

```http
GET http://example.com/comments/1/
Autrization: Bearer eyjSAvLAS19asABq1s2a
```

## 📗인코딩과 Base64URL

### 인코딩

HTTP 헤더 이름과 값들은 효율성과 안정성을 위해 미리 정해진 256개의 문자들만 사용해야 합니다. 이 문자들은 ASCII라는 표준에 포함된 문자들인데요. 이 표준을 따르면 실제로는 0과 1로 저장되는 데이터가 여러 컴퓨터에서 다르게 해석되는 걸 방지할 수 있습니다.

근데 세상에는 ASCII에 포함되지 않는 문자들도 많이 있는데요. 특히 인증 관련 데이터처럼 유저가 직접 정한 값들은 정해진 256개의 문자들만 사용한다고 가정할 수는 없습니다. 이런 걸 헤더 값으로 사용하고 싶을 때는 어떻게 할까요?

직접 ASCII에 포함된 문자로 바꿔서 사용해야 합니다.

데이터를 여러 곳에서 쉽고 안정적이게 사용하기 위해 통일된 형식으로 바꾸는 걸 '인코딩'이라고 부릅니다. 읽는 사람이 무슨 말인지 알 수 없게 만드는 '암호화'와는 조금 다른 개념이죠.

여러 인코딩 방식들이 있지만 웹에서는 base64url이 많이 사용됩니다. 이게 정확히 어떤 방식으로 인코딩하는 지는 굳이 아실 필요는 없는데요. 그냥 안정적이게, 있는 그대로의 데이터를 주고 받기 위해 base64url 이란 인코딩 방식을 사용한다 정도만 알고 계시면 충분합니다.

base64url 인코딩에 대해서는 가볍게 읽고 넘겨도 됩니다.

> ### Base64 인코딩
>
> Base64는 데이터를 0과 1로 표현하고 이걸 6자리씩 끊어서 ASCII에 포함된 64 문자 중 하나로 바꿔주는 인코딩 방식입니다. 예를 들어 `000000`는 `A`, `101000`는 `o` 이런 식으로 `000000`부터 `111111`까지 각 숫자에 해당하는 문자로 바꾸는 거죠. 참고로 ASCII에는 256개의 문자가 있는데요 이 중 64개로만 사용합니다. 64개의 문자열은 모든 영문 대소문자, 모든 숫자, 그리고 `+` 와 `/`로 이뤄져 있죠. 자릿수가 부족할 때는 `=` 문자로 체워 넣습니다.
>
> 이 방식을 사용하면 그 어떤 데이터도 인코딩할 수 있습니다. 이렇게요.
>
> ```
> À È Ì Ò Ù Ỳ Ǹ Ẁ <=> w4Agw4ggw4wgw5Igw5kg4buyIMe4IOG6gA==
> 한글도 인코딩할 수 있어요 <=> 7ZWc6riA64-EIOyduOy9lOuUqe2VoCDsiJgg7J6I7Ja07JqU
> ```
>
> 반대로 오른쪽에 데이터가 있고 이게 base64 방식으로 인코딩됐다는 걸 알면 누구나 손쉽고 빠르게 원래의 문자열로 바꿀 수 있습니다. 인코딩된 데이터를 원래 형태로 바꾸는 걸 디코딩이라고 하죠.
>
> ### Base64URL 인코딩
>
> Base64URL은 Base64과 거의 똑같은 인코딩 방식인데요. `+` 와 `/` 문자들은 URL에 사용될 때 특정 의미를 갖기 때문에 이 두 문자 대신 의미가 없는 `-` 과 `_`를 사용합니다. 웹에서 두 문자에 의미가 더 부여돼 해석될 가능성을 줄여서, 조금 더 안전하게 사용할 수 있습니다.

## 🔑 기본 인증 (Basic Authentication) (🔥중요!)

세션과 토큰 기반 로그인에 대해서 배웠습니다. 이 두 인증 방식은 문자열 형식의 문자열 형식의 "인증서" 같은 개념을 사용하잖아요? 근데 사실 인증을 할 때는 "인증서"의 개념을 아예 사용하지 않아도 되고요. 그냥 온전히 이메일과 비밀번호만 사용할 수도 있습니다.

바로 기본 인증(Basic Authentication)이라는 방식을 사용하면 됩니다.

기본 인증은 리퀘스트의 Authorizaiton 헤더를 사용하는데요. 토큰 인증을 할 때 Authorization 헤더 뒤에 Bearer 또는 Token 그리고 뒤에 토큰을 붙였던 것과 비슷하게 Authorization 헤더 뒤에 Basic, 그리고 이메일과 비밀번호를 `:`로 이어서 붙여주면 됩니다.

이렇게요: `Authorization: Basic emamil:password`

참고로 토큰 기반 인증과 기본 인증에서 Bearer/Token 또는 Basic을 붙여주는 건 서버에게 뒤에 붙이는 인증 정보의 종류를 서버에 알려 주기 위한 방법입니다. Authorization 헤더 인증을 사용한다면 꼭 추가해 주셔야 합니다.

`username: password` 이 부분은 서버로 보내기 전에 base64url 인코딩합니다.

예를 들어 인증하려는 유저의 이메일이 codeit@example.com이고, 비밀번호가 ilovecodeit이라면, 문자열로 `codeit@example.com:ilovecodeit`을 만든 후, 이 문자열을 base64url 인코딩합니다. 결과는 이렇게 나오는데요: `Y29kZWl0QGV4YW1wbGUuY29tOmlsb3ZlY29kZWl0`

그럼 헤더는 이렇게 작성하는 거죠:

`Authorization: Basic Y29kZWl0QGV4YW1wbGUuY29tOmlsb3ZlY29kZWl0`

이렇게 한 후 리퀘스트를 보내면, 서버가 Basic을 통해서 뒤에 있는 정보가 기본 인증이란 걸 파악하고, 이걸 디코딩해서 유저를 인증합니다.

### 기본 인증의 단점

기본 인증은 유저를 인증하는 자체에 있어서는 부족함이 없지만, 요즘은 거의 사용하지 않습니다. 바로 보안 문제가 생길 수 있기 때문이죠.

일단 영상에서 설명드렸듯이, 이메일과 비밀번호 조합은 누군가에서 노출됐을 때 세션 id나 토큰보다 훨씬 더 악용할 수 있는 여지가 많은데요. 모든 리퀘스트에 이런 민감한 데이터를 보내면 악의를 갖는 공격자가 중간에서 가로챌 위험이 커집니다. 또, 로그인 상태를 유지하기 위해서는 클라이언트가 이메일과 비밀번호를 어딘가에 저장해놓고, 가지고 와서 리퀘스트에 붙여야 되잖아요? 이렇게 민감한 정보를 브라우저에 저장해놓는 것도 마찬가지로 노출될 위험이 있기 때문에 안전하지 않습니다.

아직도 다양한 프레임워크들에서 세션과 토큰 기반 인증과 더불어서 기본 인증을 제공하기는 하지만, 위험하기 때문에 요즘은 거의 사용하지 않으니까요. 그냥 이런 게 있구나 정도만 알아두시고 넘어가셔도 괜찮습니다.

## ✨ Refresh 토큰 (🔥중요!)

Access 토큰은 갖고 있는 유저에게 특정 권한을 주기 위한 목적으로 사용한다고 했는데요. 사실 아무런 안전장치 없이 단독으로 사용하면 안정성 문제가 생길 수도 있습니다. 특히 토큰의 만료 기간을 길게 잡으면 토큰을 누군가 가로챘을 때 더 오랫동안 특정 권한을 갖는 유저 행세를 할 수 있는데요. 그렇다고 해서 만료 기간을 짧게 잡으면 이메일과 비밀번호로 인증을 너무 자주 해야 돼서 귀찮고 위험할 수 있습니다. 이 문제를 어느 정도 해소하기 위해서 때때로 refresh 토큰이란 걸 같이 사용합니다.

refresh 토큰은 access 토큰이 만료됐을 때, 이메일 비밀번호를 사용하지 않고 access 토큰을 새롭게 발급받는데 사용되는 토큰입니다. 어떻게 사용되는지 조금 더 자세히 알아보겠습니다.

먼저 유저가 로그인을 하기 위해서 리퀘스트로 서버에 이메일과 비밀번호를 보내고, 서버가 이걸 확인했다고 할게요. 그럼 서버는 클라이언트에서 access와 refresh, 두 가지의 토큰을 보내줄 수 있습니다.

Access 토큰이 소유자가 특정 권한을 가질 수 있게 하는 토큰이라면, refresh 토큰은 이메일과 비밀번호를 사용하지 않고 새로운 access 토큰을 발급받을 수 있게 하는 토큰입니다.

그러니까 access 토큰을 사용하다가 만료가 돼서 더 이상 리퀘스트를 인증할 수 없게 되는 경우가 생겼다고 할게요. 그럼 클라이언트는 access 토큰을 새롭게 발급받는 URL에 새로운 GET 리퀘스트를 보냅니다. 이때 body에 refresh 토큰을 함께 보내죠. 그럼 서버는 refresh 토큰이 유효한 걸 확인한 후, 새로운 access 토큰을 발급한 후, 리스폰스로 클라이언트에게 돌려줍니다.

일반적으로 refresh 토큰이 access 토큰보다 만료 기간이 더 깁니다. 정말 설정하기 나름이지만 예를 들어 access 토큰의 만료 기간이 10분이면 refresh 토큰은 24시간 이렇게요.

access 토큰의 만료 기간이 짧기 때문에 서버로 토큰을 보낼 때 누군가 이 정보를 가로챈다고 해도 최대 10분까지만 다른 유저 행세를 할 수 있습니다. 만약 누군가 가로챈다고 해도 그렇게 오래 사용할 수는 없으니 조금 더 안전하겠죠?

refresh 토큰은 access 토큰이 만료됐을 때만 보내면 되기 때문에 훨씬 더 적게 보내도 되고 그만큼 누가 빼돌릴 확률이 줄어듭니다. 클라이언트가 이 두 토큰을 저장하고 있으면, refresh 토큰이 만료할 때까지 특정 권한을 갖는다는 걸 증명할 수 있잖아요? 그렇기 때문에 이메일 비밀번호를 받지 않아도 계속 로그인 상태를 유지할 수 있어 편리하고, 이메일과 비밀번호라는 개인 정보를 리퀘스트로 최대한 적은 회수 보내도 되기 때문에 더 위험 부담을 줄일 수 있습니다.

## 📀 JWT(JSON Web Token) (🔥중요!)

JSON 형식의 데이터를 문자열로 인코딩한 토큰

![](https://velog.velcdn.com/images/pmj9498/post/da695694-aee0-4ea5-99e1-06822ee3cb13/image.png)

### Header

- 토큰 자체에 대한 데이터 저장

### PayLoad

- 토큰이 실질적으로 저장하려는 정보
- 저장하고 싶은 데이터 종류의 제한 없ㅇ므
- 최대한 짧게
- 공식 이름 최대한 활용("exp", "iat", "jti", "user_id" ...)

### Signature

- 토큰을 믿을 수 있는지 확인하기 위한 데이터 저장

## 🔑 세션 vs 토큰 기반 인증

### 효율성

토큰 기반 인증의 첫 번째 장점은 효율성입니다.

세션 기반 인증을 사용하면 서버는 항상 로그인 세션 정보를 저장하며, 매 리퀘스트의 유저가 누구인지를 이 정보와 비교를 해야 됩니다. 그리고 이걸 하기 위해서는 용량과 시간이 드는데요. 로그인한 유저가 엄청 많거나 특정 시간에 몰리게 되면 서버의 리퀘스트 처리 속도가 느려질 수도 있습니다.

반면 토큰 기반 인증은 어딘가 저장한 데이터와 비교하는 게 아니라 토큰 자체 내용을 해석하기만 하면 되기 때문에 더 효율적으로 작동할 수 있습니다.

### 유연성

토큰 기반 인증은 세션 기반 인증보다 조금 더 유연하게 사용될 수 있습니다. 토큰을 발행하는 방법이 똑같고, 시크릿 키만 있으면, 발행을 한 곳과 확인을 하는 곳이 달라도 된다는 말인데요.

예를 들어 같은 유저 데이터베이스를 사용하는 여러 서비스들이 있고, 이 사이트들이 같은 방식과 키를 사용해서 토큰을 발행한다면, 한 사이트에서 제공한 토큰을 가지고 있으면, 다른 서비스가 그걸 해석해서 유저를 파악할 수 있는거죠. 요즘은 크고 복잡한 웹 애플리케이션들을 더 작은 내용을 담당하는 작은 부분들로 나눠서 개발하는 경우가 많은데요. 이럴 때 토큰을 사용하는 게 훨씬 더 유연하죠.

### RESTful API

세션 정보와 같이 서버가 "상태" 정보를, 예를 들어 유저가 로그인을 했는지 안 했는지 저장하고 있을 때, stateful 하다고 표현하는데요. REST에 부합하기 위해서는 서버가 상태 정보를 저장하지 않는, stateless 한 특성이 있어야 합니다. 서버는 클라이언트에서 보내는 정보만으로 충분히 상태를 파악할 수 있어야 하죠.

이 기준에서 살펴보면 RESTful한 API 서버를 만들고 있다면 세션 기반 인증보다 토큰 기반 인증이 더 어울립니다.

### 무효화

세션 기반 인증의 장점 중 하나는 바로 서버에서 세션 데이터를 따로 관리를 하기 때문에 특정 세션을 손쉽게 무효화할 수 있다는 점입니다. 그냥 세션을 관리하는 테이블에 가서 상태를 만료로 바꾸거나 만료일을 지금 당장으로 해버리면 되겠죠? 하지만 토큰 기반 인증을 사용하면 따로 서버가 상태 정보를 저장하지 않기 때문에 특정 토큰을 무효화하는게 더 복잡합니다. 그리고 이건 꽤 큰 문제들로 이어질 수 있는데요. 예를 들어 금융 서비스에서 누군가 유저 토큰을 가로챘는데 이걸 바로 무효화할 수 없다면 저금해놓은 돈을 뺏기는 문제가 생길 수도 있죠. 물론 이중 비밀번호나, OTP라든지 이걸 방지하기 위한 방법들이 있지만, 세션 기반 인증을 사용하면 한 가지 안전장치를 더 손쉽게 사용할 수 있습니다.

## 🔑 Authorization (🔥중요!)

> 보낸 유저가 누구인가 : 인증
> 리퀘스트 내용을 요청할 권한이 있는가 : 인가

리퀘스트를 보낸 유저가 "누구인지" 파악하는 **인증**과 리퀘스트가 "특정 작업을 요청할 권한이 있는지" 파악하는 **인가**는 서로 다른 두 기능이라고 강조했습니다.

근데 생각해 보면 리퀘스트의 Authorization(인가) 헤더를 이용하는 유저 인증 방법을 배웠는데, 이런 식으로 사용했죠.

```
DELETE http://www.example.com/api/some_resource/1/
Authorization: Bearer <token>
```

### 📗 Authorization 헤더를 인증에 사용하는 이유

> 근데 인증하기 위해서 Authorization, 인가라는 이름의 헤더를 사용하는 게 조금 이상하지 않으신가요?
>
> 관련 [공식 문서](https://www.rfc-editor.org/rfc/rfc7235#section-4.2)를 읽어보면 Authorizaiton은 인가가 아닌 인증 데이터를 보내기 위한 헤더라고 정의돼있습니다. 유저 기능의 두 용어를 구별해서 사용하는 요즘 기준으로 생각하면 이름을 그냥 잘못 지은 건데요. 그 배경에 대해서 정확히 알 수는 없지만, 약 20여 년 전 문서를 작성할 당시에는 두 단어를 구별하지 않고 사용했었거나, 리퀘스트를 인가하기 위해서 당연히 인증 정보를 사용해야만 한다고 생각해서 지은 거로 추측됩니다.
>
> 이렇게 헷갈리는 이름 실수를 왜 바로 잡지 않고 있는 걸까요? 사실 이 부분도 제가 해당 내용의 저자가 아니기 때문에 정확한 답변을 할 수 없고 추측만 할 수 있는데요.
>
> 이미 Authorization 헤더를 너무 널리 사용하기 때문에 이름을 바꾸면 많은 것들을 망가트릴 수 있거나, 두 개의 기준이 섞여 사용돼서 혼란을 일으킬 수 있기 때문으로 생각됩니다. 예를 들어 어떤 곳에서는 바뀌기 전 헤더를 사용하고, 다른 곳에서는 바뀐 헤더를 사용하면, 기존 서비스가 제대로 작동하지 않거나, 연동을 하려고 할 때 문제가 생길 수도 있겠죠? 또 그렇다고, 모든 백엔드와 프론트엔드 프로그램을 두 개의 헤더를 다 처리하도록 설정해야 하면, 개발자와 컴퓨터의 리소스가 낭비됩니다. 이런 복잡한 문제를 발생시키지 않기 위해서 헤더 이름을 수정할 강한 필요성을 못 느끼는 거 같습니다.

이유가 어찌 됐던, Authorizaiton 헤더 인가가 아닌 인증을 위한 헤더라는 점을 이해하고 사용하면 됩니다.

## 📝 다양한 OAuth/OpenID 플로우

이번에는 권한 위임 프로토콜인 OAuth와 인증 프로토콜인 OIDC에 대해서 배웠는데요. 사실 OAuth와 OIDC는 이번에 배운 플로우만 있는 게 아니라, 여러 종류가 있습니다. 저희는 그 중 가장 많이 사용되고 권장되는 Authorizaiton Code 플로우에 대해서만 살펴봤습니다.

이번 레슨에서는 또 다른 워크플로우인 Implicit 플로우에 대해서 배워보고, 왜 Implicit 플로우보다 Authorizaiton Code 플로우가 더 권장되는지에 대해서 알아보겠습니다.

먼저 OAuth를 배웠을 때 예시로 봤던 상황을 그대로 가지고 와서 설명드릴게요.

코드잇에서 유저들이 학습 목표를 달성할 수 있게 스케쥴링을 도와주는 기능을 추가하고 싶습니다. 이 기능을 유저의 구글 캘린더와 연동하면 좋을 거 같은데요. 쉽게 말해서 코드잇 사이트가 구글로부터 스케줄 정보에 대한 접근 권한을 위임받고 싶습니다.

이 상황에 나오는 주체들은:

- 먼저, 구글 캘린더에 있는 본인 리소스를 받아오려는 유저가 있습니다.
- 그리고 코드잇 사이트 프론트엔드와 백엔드가 있고요.
- 다음은 구글 서비스들의 인가 기능을 담당하는 인가 서버,
- 그리고 스케줄 데이터가 저장돼있는 구글 캘린더에 해당하는 리소스 서버가 있습니다.

사실 둘 다 OAuth의 다른 플로우여서 비슷한 점들이 많은데요. 겹치는 부분은 최대한 빨리 지나갈게요.

먼저 인가 서버에서 OAuth를 쓰기 위한 설정을 합니다. 실제로 설정을 할 때는 더 많은 내용이 있지만, 위임받으려는 권한의 범위 Scope를 설정하고 Client ID와 Secret을 발급받습니다. Implicit Code Flow에서 Client Secret은 사용되지 않고요. Client ID는 프론트엔드에 저장해놓습니다.

이제부터 OAuth를 사용할 수 있는데요. 그럼 코드잇 프론트엔드는 유저에게 인가 서버로부터 권한을 위임해달라고 요청합니다. 그럼 유저는 이메일과 비밀번호를 사용해서 구글에게 신원을 증명하죠. 신원이 증명되면 Authorization Code 플로우에서는 코드잇 프론트엔드에게 authorization code를 발행해 주는데요. Implicit 플로우에서는 access token 자체를 리턴 받습니다. OpenID Connect를 사용하고 있다면 여기서 바로 id token을 리턴받죠.

코드잇 프론트엔드는 이걸 다시 백엔드로 전달하고, 백엔드는 이걸 사용해서 리소스 서버에 접근합니다.

사실 Implicit 플로우를 사용하면 이전보다 훨씬 더 간단하게 OAuth를 사용할 수 있는데 왜 Authorization Code 플로우가 권장될까요?

바로 **안정성** 때문입니다.

사실 access token을 갖고 있으면 리소스 서버에 여러 작업들을 요청할 수 있고, id token은 유저의 개인 정보를 담고 있기 때문에 믿을 수 없는 사람에게 유출되면 안 되는데요. Implicit 플로우를 사용하면 access token이 클라이언트 코드와 브라우저, 그리고 브라우저가 실행되고 있는 개인 컴퓨터에까지 노출되기 때문에 중간에 누군가가 가로챌 수 있는 가능성이 있습니다.

또 프론트엔드에 저장된 정보는 백엔드 서버에 저장하는 것과는 달리 노출되기가 쉬운데요. 그렇기 때문에 Client Secret과 같이 민감한 정보를 저장하고 사용할 수 없습니다. Client Secret을 사용하지 않고 access token을 발급하면 access token을 발급하는 대상이 정말 코드잇 서비스인지 확인하기 어려운데요. 코드잇이 아닌 다른 사이트에 access token을 발급하는 것도 꽤 위험합니다.

Authorization Code를 사용하면 어떨까요? 프론트앤드는 Authorization code만 갖고 있고, Client Secret은 오직 백엔드 서버에만 저장돼있습니다. Authorization code의 유일한 기능은 인가 서버에 보내서 access나 id 토큰을 발행 받는 건데요. 이때 Client ID와 Secret을 함께 보내야 하잖아요? 이 두 데이터는 프론트앤드에 저장하지 않기 때문에 누군가 악의를 갖고 클라이언트 쪽에서 Authorization Code를 가로챈다고 해도 사용할 수 없습니다.

오직 인가 서버와 백앤드 서버만 알고 있는 Client ID와 Secret을 사용하면, 항상 믿을 수 있는 사이트에만 민감한 데이터인 access와 id token을 보낼 수 있죠.

이런 문제가 생길 수 있기 때문에 OAuth를 사용할 때는 조금 더 간단한 Implicit 플로우보다, 번거로운 Authorization Code 플로우를 사용하는 게 권장됩니다.

OAuth는 Implicit 플로우, Authorization Code 플로우뿐만 아니라, Hybrid 플로우, Client-Credentials 플로우 등 다양한 방식들을 통해 사용할 수 있는데요. 대부분의 상황에서는 Authorization Code 플로우가 가장 권장되고 실제로 많이 사용하고 있기 때문에 이번 챕터에서는 이거 하나만 자세히 배우고 넘어가겠습니다. 혹시 다른 플로우들이 궁금하신 분들은 공식 문서에 나와있는 내용들을 확인해 보시는 걸 추천드립니다.

> https://oauth.net/2/grant-types/

# React에서 유저 기능 구현하기

## 🍪 리퀘스트에서 쿠키 사용하기

이번에는 사이트의 `Origin` 이라는 개념에 대해서 간단히 알아보고, 서로 사이트가 다른 Cross Origin 상황에서 `fetch()` 함수와 Axios에서 리퀘스트를 보낼 때 사용하는 Credential 옵션에 대해 더 자세히 알아봅시다.

### Origin이란?

`Origin`이란 쉽게 말해서 리퀘스트를 보내는 사이트의 도메인입니다. 이번 강의에서는 `http://localhost:3000`이라는 리액트로 만든 사이트에서 `https://learn.codeit.kr/api/...` 이라는 실습용 백엔드 서버의 주소로 리퀘스트를 보내고 있죠? 이때 리액트로 만든 사이트의 Origin은 `http://localhost:3000`이고, 실습용 서버의 Origin은 `https://learn.codeit.kr`입니다. 참고로 `:3000` 부분은 *포트 번호*라고 하는데요. 이 포트 번호도 Origin에 포함됩니다.

> 포트 번호란?
> 사실 우리가 사용하는 사이트 도메인은 실제로 192.168.0.1 같은 숫자로 된 IP 주소입니다. IP 주소가 컴퓨터를 찾는 번호라면, 포트 번호는 한 컴퓨터 안에서도 어떤 프로그램을 이용할 것인지 찾는 번호입니다. 일반적으로 HTTP 통신에는 80번 포트를 쓰는데, 그래서 웹사이트 주소에는 `:80` 포트 번호를 써 주어야 하지만 일반적으로 생략해서 쓰고 있습니다.

`http://localhost:3000`에서 `https://learn.codeit.kr`로 리퀘스트를 보내는 경우, 서로 다른 Origin이라는 의미에서 Cross Origin이라고 표현하는데요. 이런 경우 여러 가지 보안 문제가 발생할 수 있기 때문에 특별히 주의해야 합니다. 혹시 CORS(Cross-Origin Resource Sharing)이라는 말 들어보셨나요? CORS는 웹 개발에서 자주 겪기도 하고 아주 중요한 문제입니다. 혹시 CORS에 대해서 더 궁금하신 분들은 [CORS란?](https://www.codeit.kr/tutorials/95/CORS%EB%9E%80%3F)을 참고해 보세요.

### Credential이란?

영어에서 Credential이란 "자격", "증명서" 같은 의미입니다. 웹 개발에서 `Credential` 이라고 하면 유저를 증명할 수 있는 정보들을 말합니다. 예를 들면 아이디와 비밀번호라던지 서버에서 발급받은 토큰 같은 것들을 말하죠. 리퀘스트를 보내는 상황에서 주로 쿠키를 말합니다.

### Axios에서 Credential 사용하기

Axios에서는 `withCredentials` 라는 옵션을 불린형으로 지정할 수 있습니다. 이 값을 `true`로 설정해야만 Cross Origin에 쿠키를 보내거나 받을 수 있는데요. 참고로 이건 `fetch()` 함수에서 `credentials: 'include'` 를 설정하는 것과 같습니다. 이 내용에 대해선 아래에서 자세히 살펴보도록 하죠.

```js
axios.post(
  "/auth/login",
  { email: "sunny@sundaymorning.kr", password: "t3st!" },
  { withCredentials: true }
);
```

### `fetch()` 함수에서 Credential 사용하기

`fetch()` 함수에서 리퀘스트를 보낼 때 쿠키를 사용하려면 적절한 `credentials` 옵션을 설정해 주어야 합니다.

- `'omit'`: 쿠키를 사용하지 않습니다. 리퀘스트를 보낼 때도 쿠키를 사용하지 않고, 리스폰스로 `Set-Cookie` 헤더를 받았을 때에도 쿠키를 저장하지 않습니다.
- `'same-origin'`: 아무 옵션을 지정하지 않았을 때 기본 값입니다. 같은 Origin인 경우에만 쿠키를 사용하겠다는 옵션입니다. Origin은 쉽게 말해서 사이트의 도메인이라고 했죠? 프론트엔드 사이트 주소와 리퀘스트를 보낼 백엔드 서버의 주소가 다르다면 Cross Origin이라고 이해하시면 됩니다.
- `'includ'`: 이 옵션을 사용하면 Cross Origin인 경우에도 쿠키를 사용합니다.

이번 토픽에서는 코드잇에서 제공하는 실습 서버를 사용할 거기 때문에, 여러분이 코드잇 실행기를 쓰거나 개인 컴퓨터에서 개발을 하고 계신다면 Cross Origin 리퀘스트를 보내게 됩니다. 따라서 `'include'` 옵션을 설정해야 하는데요. 예를 들어서 로그인을 한다면 아래와 같이 `credentials: 'include'` 옵션을 설정해야 쿠키를 사용할 수 있습니다.

```js
fetch("https://learn.codeit.kr/api/link-service/auth/login", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ email: "sunny@sundaymorning.kr", password: "t3st!" }),
  credentials: "include",
});
```

우선은 코드잇의 실습 서버가 "내 프론트엔드 사이트와 다른 Origin이기 때문에" CORS에서 쿠키를 사용하려면 `credentials: 'include'`를 설정해야 한다는 점을 잘 이해하고 넘어가 주세요. 만약 실제 사이트 개발을 백엔드 서버와 같은 Origin에서 진행한다면 굳이 설정하지 않아도 괜찮습니다. (기본 값이 `'same-origin'`이므로)

## 🍪 쿠키가 제대로 저장되지 않을 때

만약 여러분이 유저 기능을 개발할 때 쿠키가 저장이 안됐다면 크게 두 가지 이유를 생각해 볼 수 있습니다. 프론트가 잘못됐거나 백엔드가 잘못됐거나, 둘 중 하나죠.

프론트엔드의 경우 앞에서 우리가 해봤던 것처럼 REST Client로 테스트했을 때 잘 동작하는지 확인 해보고, Cross Origin인 경우 프론트에서 리퀘스트를 보내는 코드에 `withCredentials` 옵션을 적절하게 설정해 줬는지 확인해 봤다면, 쿠키를 저장하는데 문제가 없다고 생각해도 좋습니다.

만약 그래도 쿠키 저장이 안 됐다면, 쿠키 옵션의 문제일 가능성이 높은데요. 이럴 땐 의심되는 부분을 찾아서 백엔드 개발자에게 확인을 부탁하면 되겠죠? 이번 레슨에서는 쿠키가 제대로 저장되지 않을 때 프론트엔드에서 확인해 볼 수 있는 것들에 대해 알아보도록 하겠습니다.

### 리스폰스 헤더의 `Set-Cookie` 확인하기

우선 개발자 도구의 Network 탭에서 리스폰스 헤더를 확인해 보면 됩니다. Headers라는 탭에서 Response Headers 안에 있는 `Set-Cookie` 값을 확인해 보세요.
![](https://velog.velcdn.com/images/pmj9498/post/6201f81d-72d9-49d0-9c04-354319986c62/image.png)

위 스크린샷은 제가 다른 도메인을 가진 백엔드 서버에서 `SameSite=Strict`라는 옵션으로 쿠키를 만든 경우입니다. 리퀘스트를 보내는 쪽은 도메인이 `localhost`인데요. 받는 쪽의 도메인이 달라서 쿠키가 저장되지 않은 경우입니다. Response Headers 부분에서 `Set-Cookie` 값을 보니까 쿠키들이 `SameSite=Strict`로 설정되어 있네요.

크롬 개발자 도구에선 이럴 때 경고 표시 아이콘으로 알려주기도 합니다. 에러 메시지를 보면 아래와 같은데요. `SameSite=Strict` 옵션이지만 도메인이 다른(크로스 사이트) 리스폰스이기 때문에 쿠키를 저장하지 않았다는 의미입니다.

```
This attempt to set a cookie via a Set-Cookie header was blocked because it had the "SameSite=Strict" attribute but came from a cross-site response which was not the response to a top-level navigation.
```

참고로 리스폰스로 받은 `Set-Cookie` 헤더는 오른쪽 상단에 있는 `Cookies` 탭을 사용하면 표 형태로 좀 더 편하게 확인할 수 있습니다.
![](https://velog.velcdn.com/images/pmj9498/post/349ab956-f4b9-4526-8455-f03bc5f5730f/image.png)

### SameSite 옵션

`SameSite`라는 옵션에 대해 좀 더 자세히 알아 보겠습니다. `SameSite`는 리퀘스트를 보내는 쪽의 도메인과 리퀘스트를 받는 쪽의 도메인이 일치하는지 확인하고 쿠키의 사용을 허용하는 옵션인데요. 이런 옵션은 백엔드 쪽에서 설정할 수 있습니다.

이번 강의에서 사용한 코드잇 실습 서버의 경우 수강생들이 `localhost`에서도 쿠키를 사용할 수 있도록 하려고 `SameSite`=None이라는 옵션으로 쿠키를 만들고 있습니다. 이렇게 하면 리퀘스트를 보내는 쪽과 받는 쪽의 도메인이 다르더라도 쿠키를 저장할 수 있죠.

좀 더 엄격한 규칙으로는 `SameSite=Strict`라는 옵션이 있는데요. 이 옵션을 사용하게 되면 반드시 리퀘스트를 보내는 쪽과 받는 쪽이 같은 도메인이어야 쿠키를 저장하고 사용할 수 있습니다. 혹시 `SameSite` 옵션에 대해서 더 자세히 궁금하신 분들은 [쿠키의 SameSite 옵션이란?](https://www.codeit.kr/tutorials/94/%EC%BF%A0%ED%82%A4%EC%9D%98%20SameSite%20%EC%98%B5%EC%85%98%EC%9D%B4%EB%9E%80%3F)을 참고해주세요.

### 의심되는 원인을 찾았다면?

그 밖에도 `Set-Cookie` 헤더의 값을 보았을 때 쿠키가 저장되지 않는 다양한 이유가 있을 수 있는데요. 이 값들은 리스폰스로 오는 것이기 때문에 프론트엔드 영역에서는 수정할 수 없습니다. 이럴 땐 개발자 도구에서 리퀘스트 헤더와 리스폰스 헤더를 복사해서 백엔드 개발자에게 확인을 요청해 보세요.

## 워크플로 (이미지로 복습)

### 회원가입

![](https://velog.velcdn.com/images/pmj9498/post/21437746-d144-4a75-b59d-fa2040d3fcca/image.png)

### 로그인

![](https://velog.velcdn.com/images/pmj9498/post/46ce3cc8-f788-4ed0-ae9c-b6e52d423537/image.png)

### 유저 데이터 가져오기

![](https://velog.velcdn.com/images/pmj9498/post/f08e313d-23f3-49b7-96eb-2f35dddc3cdd/image.png)

### 토큰 갱신하기

![](https://velog.velcdn.com/images/pmj9498/post/da37b957-4d14-4aa0-bc2f-cd327075b1d5/image.png)

### 로그아웃

![](https://velog.velcdn.com/images/pmj9498/post/e4c30bb3-7ed5-41fa-9fe3-3272bce1472b/image.png)

### 구글 로그인

![](https://velog.velcdn.com/images/pmj9498/post/67d18930-7cdf-487c-b6a4-43e59954e9d7/image.png)
