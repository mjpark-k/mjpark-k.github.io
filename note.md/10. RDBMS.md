# 관계형 데이터베이스를 활용한 자바스크립트 서버 만들기(prisma, postgreSQL)

# Prisma 기본기

## 예시 comazon 프로젝트로 단계 알아보기

**1. package.json 설정**

필요한 패키지(`devDependencies`, `dependencies`)와 모듈 타입(`type`) 그리고 커맨드(`scripts`)를 정의한다.

```json
{
  "dependencies": {
    "@prisma/client": "^5.4.2",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "is-email": "^1.0.2",
    "is-uuid": "^1.0.2",
    "prisma": "^5.4.2",
    "superstruct": "^1.0.3"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  },
  "type": "module",
  "scripts": {
    "dev": "nodemon app.js",
    "start": "node app.js"
  }
}
```

**2. 패키지 설치**

- `nodemon`: 코드에 변경 사항이 있으면 자동으로 서버를 재시작해 주는 라이브러리(개발 환경에서만 필요)
- `prisma`: Prisma 관련 커맨드를 실행하는 데 필요한 라이브러리
- `@prisma/client`: Prisma 관련 코드를 실행하기 위해 필요한 라이브러리
- `express`: 자바스크립트로 API를 만들기 위한 라이브러리
- `superstruct`: 유효성 검사를 할 때 사용하는 라이브러리
- `is-email`: 값이 이메일 형식인지 확인할 때 사용하는 라이브러리
- `is-uuid`: 값이 UUID 형식인지 확인할 때 사용하는 라이브러리
- `dotenv`: 환경 변수 설정에 필요한 라이브러리

`package.json` 파일에 명시된 패키지들이 모두 설치(terminal에서 커맨드 실행)

```
npm install
```

3. **VScode Prisma 익스텐션 설치** -> Prisma 코드 syntax 하이라이팅, 문법검사, 포매팅 기능을 제공

4. **PostgresSQL 설치**

5. **Prisma와 데이터베이스 초기화**

PostgreSQL을 사용하도록 초기화

```
npx prisma init --datasource-provider postgresql
```

> Prisma 커맨드는 `npx prisma`로 시작됨

> **자동 Formatting(VScode Prisma 익스텐션 기능)**  
> window: `Shift + Alt + F `

## Prisma 설치와 초기화

`Prisma`를 사용하려면 `prisma` 패키지와 `@prisma/client` 패키지를 설치해야 합니다.

```
npm install prisma --save-dev
npm install @prisma/client
```

`prisma`는 **Prisma 관련 커맨드를 실행하는데 필요한 라이브러리**이고, `@prisma/client`는 **Prisma 관련 코드를 실행하기 위해 필요한 라이브러리**입니다. `prisma`는 보통 dev dependency로 설치합니다.

VSCode의 Prisma 익스텐션도 설치해 주는 것이 좋음

`prisma` 설치를 완료했으면 아래 커맨드로 초기화 가능

```
npx prisma init --datasource-provider db-type
```

`db-type`은 `postgresql`, `mysql`, `sqlite` 등으로 설정할 수 있습니다. `.env` 파일에 있는 정보를 환경에 맞게 수정하세요.

`postgrsql`을 사용하려면 macOS에서는 컴퓨터 유저 이름과 비밀번호, Windows에서는 postgres와 설치 시 설정한 비밀번호를 사용하면 됩니다.

## Prisma Schema

`schema.prisma`라는 파일에 필요한 모델들을 정의합니다.

```prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  firstName String
  lastName  String
  address   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Product {
  id          String   @id @default(uuid())
  name        String
  description String?
  category    Category
  price       Float
  stock       Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

enum Category {
  FASHION
  BEAUTY
  SPORTS
  ELECTRONICS
  HOME_INTERIOR
  HOUSEHOLD_SUPPLIES
  KITCHENWARE
}
```

각 필드는 필드 이름, 필드 타입, 어트리뷰트(옵셔널)로 구성돼 있습니다. 필드 타입은 `?`를 사용해서 필수 여부를 정할 수 있고 자주 사용하는 어트리뷰트는 아래와 같습니다.

- `@id`: 필드가 id라는 것을 나타냄
- `@unique`: 고유 필드(값이 중복될 수 없음)라는 것을 나타냄
- `@default`: 디폴트 값을 설정할 때 사용
- `@updatedAt`: 객체가 수정될 때마다 수정 시간을 필드에 기록함

위처럼 필드의 값이 정해진 값 중 하나라면 enum을 사용할 수도 있습니다.

--

## Prisma Migration

schema.prisma 파일을 변경하면 마이그레이션이라는 것을 해 줘야 합니다. 마이그레이션은 스키마 파일의 내용을 데이터베이스에 반영해 주는 것입니다.  
예를 들어 shcema.prisma에 새로운 모델을 정의하고 마이그레이션을 하면 Prisma는 새로운 테이블을 생성하는 SQL문을 만들어서 실행해 줍니다.

```
npx prisma migrate dev

√ Enter a name for the new migration: ... init
```

> 웹으로 데이터 확인하는 법

```
npx prisma studio
```

## Prisma Client

Prisma Client는 모델 정보를 저장하고 있고 이걸 기반으로 데이터베이스와 상호작용합니다. 마이그레이션을 할 때마다 최신 모델 정보를 기반으로 Prisma Client를 생성해 주죠. 모든 데이터베이스 연산은 Prisma Client를 통해 이루어집니다.

```js
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();
```

연산은 `prisma.model.method()` 형태이며 **Promise**를 리턴합니다. 이 연산을 '쿼리'라고도 부릅니다.

```js
const id = "b8f11e76-0a9e-4b3f-bccf-8d9b4fbf331e";

const userData = {
  email: "yjkim@example.com",
  firstName: "유진",
  lastName: "김",
  address: "충청북도 청주시 북문로 210번길 5",
};

// 여러 유저 조회
const users = await prisma.user.findMany();

// 유저 1명 조회
const user = await prisma.user.findUnique({
  where: {
    id,
  },
});

// 유저 생성
const user = await prisma.user.create({
  data: userData,
});

// 유저 수정
const user = await prisma.user.update({
  where: {
    id,
  },
  data: {
    email: "yjkim2@example.com",
  },
});

// 유저 삭제
const user = await prisma.user.delete({
  where: {
    id,
  },
});
```

`where`는 필터를 할 때 사용하고, `data`는 데이터를 전달할 때 사용합니다.  
`.findMany()` 메소드에는 아래 프로퍼티도 많이 사용됩니다.

- `orderBy`: 정렬 기준
- `skip`: 건너뛸 데이터 개수
- `take`: 조회할 데이터 개수

예를 들어 URL 쿼리 파라미터와 아래를 아래와 같이 사용할 수 있습니다.

```js
app.get("/users", async (req, res) => {
  const { offset = 0, limit = 10, order = "newest" } = req.query;
  let orderBy;
  switch (order) {
    case "oldest":
      orderBy = { createdAt: "asc" };
      break;
    case "newest":
    default:
      orderBy = { createdAt: "desc" };
  }
  const users = await prisma.user.findMany({
    orderBy,
    skip: parseInt(offset),
    take: parseInt(limit),
  });
  res.send(users);
});
```

그 외에 추가적인 CRUD 메소드(Client 메소드)는 [문서](https://prisma.io/docs/orm/reference/prisma-client-reference#model-queries)를 통해 확인

그 외에 필터 조건에 대한 내용은 [문서](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-conditions-and-operators)를 통해 확인

## 데이터베이스 시딩

Prisma Client를 이용해서 데이터베이스 시딩도 할 수 있습니다. `.createMany()` 메소드를 사용하면 배열 데이터를 한꺼번에 삽입할 수 있습니다.(SQLite에서는 메소드를 사용할 수 없음)

```js
// seed.js
import { PrismaClient } from "@prisma/client";
import { USERS, PRODUCTS } from "./mock.js";

const prisma = new PrismaClient();

async function main() {
  // 기존 데이터 삭제
  await prisma.user.deleteMany();
  await prisma.product.deleteMany();

  // 목 데이터 삽입
  await prisma.user.createMany({
    data: USERS,
    skipDuplicates: true,
  });

  await prisma.product.createMany({
    data: PRODUCTS,
    skipDuplicates: true,
  });
}

main()
  .then(async () => {
    await prisma.$disconnect();
  })
  .catch(async (e) => {
    console.error(e);
    await prisma.$disconnect();
    process.exit(1);
  });
```

```js
// mock.js
export const USERS = [
  // ...
];

export const PRODUCTS = [
  // ...
];
```

`package.json` 파일에 `see`d 커맨드를 정의하면 Prisma 커맨드로 시딩할 수 있다.

```json
// package.json
{
  // ...
  "prisma": {
    "seed": "node prisma/seed.js"
  }
}
```

`"node prisma/seed.js"` 부분은 시드 연산을 실행하는 파일 경로  
아래 커맨드로 시딩을 할 수 있다.

```
npx prisma db seed
```

## 쿼리 파라미터 처리

```js
app.get("/users", async (req, res) => {
  const { offset = 0, limit = 10, order = "newest" } = req.query;
  let orderBy;
  switch (order) {
    case "oldest":
      orderBy = { createdAt: "asc" };
      break;
    case "newest":
    default:
      orderBy = { createdAt: "desc" };
  }
  const users = await prisma.user.findMany({
    orderBy,
    skip: parseInt(offset),
    take: parseInt(limit),
  });
  res.send(users);
});
```

## 유효성 검사

다양한 방식으로 유효성 검사를 할 수 있지만 이번 토픽에서는 `superstruct`라는 라이브러리로 유효성 검사를 진행한다. 예상하는 데이터 형식을 정의하고 실제 데이터를 비교하는 방식으로 먼저 패키지들을 설치해야 한다.

> 그 전에 먼저 `superstruct`가 깔려있는지 확인해야 한다. `npm list`로 설치된 패키지를 확인

```
npm list
```

![](https://velog.velcdn.com/images/pmj9498/post/be137f79-f839-4052-af0e-cdb763ab60c0/image.png)

없다면 아래 커맨드로 설치

```
npm install superstruct is-email is-uuid
```

`is-email`은 이메일 형식을 확인하고 싶은 경우 설치하면 되고, `is-uuid`는 UUID 형식을 확인하고 싶은 경우 설치하면 된다.

`superstruct` 라이브러리의 `.string()`, `.number()`, `.integer()`, `.boolean()`, `.define()`, `.object()`, `.enums()`, `.array()`, `.partial()` 타입들로 틀을 정의하고 `.size()`, `.min()`, `.max()` 함수로 제약을 추가하면 됩니다.

```js
// struct.js
import * as s from "superstruct";

const CATEGORIES = [
  "FASHION",
  "BEAUTY",
  "SPORTS",
  "ELECTRONICS",
  "HOME_INTERIOR",
  "HOUSEHOLD_SUPPLIES",
  "KITCHENWARE",
];

export const CreateUser = s.object({
  email: s.define("Email", isEmail),
  firstName: s.size(s.string(), 1, 30),
  lastName: s.size(s.string(), 1, 30),
  address: s.string(),
});

export const PatchUser = s.partial(CreateUser);

export const CreateProduct = s.object({
  name: s.size(s.string(), 1, 60),
  description: s.string(),
  category: s.enums(CATEGORIES),
  price: s.min(s.number(), 0),
  stock: s.min(s.integer(), 0),
});

export const PatchProduct = s.partial(CreateProduct);
```

데이터를 비교할 때는 `assert()` 함수를 사용하면 된다.

```js
// app.js
import { assert } from "superstruct";
import { CreateUser } from "./structs.js";

// ...

app.post("/users", async (req, res) => {
  assert(req.body, CreateUser); // CreateUser 형식이 아니라면 오류 발생
  // ...
});
```

## 오류 처리

```js
// app.js
import { PrismaClient, Prisma } from "@prisma/client";

// ...

function asyncHandler(handler) {
  return async function (req, res) {
    try {
      await handler(req, res);
    } catch (e) {
      if (
        e instanceof Prisma.PrismaClientValidationError ||
        e.name === "StructError"
      ) {
        res.status(400).send({ message: e.message });
      } else if (
        e instanceof Prisma.PrismaClientKnownRequestError &&
        e.code === "P2025"
      ) {
        res.sendStatus(404);
      } else {
        res.status(500).send({ message: e.message });
      }
    }
  };
}

// ...

app.post(
  "/users",
  asyncHandler(async (req, res) => {
    assert(req.body, CreateUser);
    // ...
  })
);
```

- `e.name === 'StructError'`: Superstruct 객체와 형식이 다를 경우 발생
- `e instanceof Prisma.PrismaClientValidationError`: 데이터를 저장할 때 모델에 정의된 형식과 다른 경우 발생(Superstruct로 철저히 검사하면 이 상황은 잘 발생하지 않지만 안전성을 위해 둘 다 검사)
- `e instanceof Prisma.PrismaClientKnownRequestError && e.code === 'P2025'`: 객체를 찾을 수 없을 경우

# 관계형 데이터베이스 기본기

## Primary Key와 Foreign Key

![](https://velog.velcdn.com/images/pmj9498/post/a91cf34b-6015-4127-83d7-385eedeaf0fb/image.png)
![](https://velog.velcdn.com/images/pmj9498/post/ab73793f-896e-476c-a4a8-12ea28a4e67f/image.png)

## 데이터 모델링

서비스에 정확히 어떤 데이터가 필요하고 데이터 간 어떤 관계가 있는지를 파악해서 정교하게 표현하는 것

### ER 모델(Entity-Relationship 모델)

이는 **ER 다이어그램**이라고도 부름

- **개체(Entity)**
  - 현실 세계의 사물 또는 객체
  - 예: 유저, 상품, 주문
  - 하나의 개체 = 하나의 테이블
- **속성(Attribute)**
  - 개체의 세부 정보
  - 예: 유저의 성, 이름, 이메일
  - 하나의 속성 = 하나의 컬럼
- **관계(Relationship)**
  - 개체 간의 관계
  - 예: 유저는 주문을 할 수 있다. / 주문은 여러 상품을 포함한다.

## ER 모델링: 개체, 속성, 관계 후보 찾기

**Business Rule(사업 규칙)**: 사업이나 서비스가 운영되기 위해 따르는 규칙
![](https://velog.velcdn.com/images/pmj9498/post/bb748e76-259b-4b50-8140-fbed31ce7e16/image.png)

**개체**: 사용자, 상품, 주문

**속성**:

- 사용자: 이메일, 성, 이름, 주소, 이메일 수신 여부
- 상품: 이름, 설명, 가격, 카테고리, 재고
- 주문: 주문 수량, 가격, 주문 시 상품의 가격, 상품의 원 가격, 재고, 상태
- 그 외: 생성 시간, 수정 시간

**관계**: 두 개체간의 관계를 묘사하는 동사의 집중

- 찜하다
- 주문하다
- 포함하다

![](https://velog.velcdn.com/images/pmj9498/post/8183ec58-9fa7-4a30-8ba5-6f187eecf270/image.png)

![](https://velog.velcdn.com/images/pmj9498/post/845516f4-9af7-49fb-9f6c-afcd8d9c6571/image.png)

## ER 모델링: 카디널리티(Cardinality)

특정 데이터 집합의 유니크한 값의 개수

> 개체간의 관계가 있을 때, A 개체 한 개가 B 개체 몇 개와 연결될 수 있고, B 개체 한 개가 A 개체 몇 개와 연결될 수 있는지를 뜻함.

ER 모델(최대 카디널리티만 포함)
![](https://velog.velcdn.com/images/pmj9498/post/361a2090-f32c-4b48-96a9-d4648ba333b4/image.png)

(최소 카디널리티도 포함)

![](https://velog.velcdn.com/images/pmj9498/post/b9800c3a-4324-478d-99ea-c6f4e3b81aad/image.png)

## ER 모델 => 데이터베이스 테이블

**<1 대 다>** 관계는 '다' 쪽 개체 테이블에 foreign key를 추가하면 된다.
![](https://velog.velcdn.com/images/pmj9498/post/cfac56b5-baea-4495-a86e-21a9ac676277/image.png)

**<1 대 1>** 관계는 UserPreference에 foreign key 컬럼을 추가해주고 UNIQUE하게 만들어준다.
1 대 1이라 User에 반대로 추가해줘도 되지만, 하나의 개체가 다른 개체의 속해있나 생각해보면 보통 개체의 속해 있는 쪽에 설정해주는 것이 좋다.

![](https://velog.velcdn.com/images/pmj9498/post/8191663e-30d0-4eff-95c1-1cba4aea1dbb/image.png)

**<다 대 다>** 관계는 테이블에 직접 foreign key를 정의하지 않고 하나의 새로운 junction table을 만들어야 한다. foreign key 컬럼 하나만으로는 다 대 다 관계를 저장할 수 없기 때문이다.

![](https://velog.velcdn.com/images/pmj9498/post/c6877d4c-4b64-4c79-9630-9d89baf23af2/image.png)

이것들을 모두 ER 모델에 반영하면(파란색은 foreign key)
![](https://velog.velcdn.com/images/pmj9498/post/a1ab385b-4073-45db-8281-533a7367948e/image.png)
