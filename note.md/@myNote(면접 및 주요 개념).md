# 정리

### ✔ DOM

DOM(Document Object Model)은 문서 객체 모델로, 웹페이지 내용을 대변하고 수정할 수 있는 객체의 규격, 간단하게 설명하면 웹 페이지에 나타나는 HTML 문서 전체를 객체로 표현한 것으로 생각하면 된다.  
document 객체: 우리가 보고있는 웹페이지의 내용을 대변하는 DOM 객체

DOM 문서(document)는 트리 구조 (나무처럼 가지를 뻗어나가는 형태)

Parent node(부모 노드), Child node(자식 노드), Sibling node(형제 노드)

Text node(텍스트 노드), Element node(요소 노드)

### ✔ Promise와 async / await

콜백 기반 코드는 모든 작업을 함수 안에서 처리하기 때문에 작업을 이어서 하려면 콜백 안에 콜백을 등록해야 합니다. 그렇기 때문에 콜백을 중첩해서 사용해야 하는 이런 현상을 **콜백 헬(callback Hell)**이라고 부릅니다.

콜백 헬(callback Hell)로 인해 코드를 이해하기도 힘들고, 디버깅이나 테스팅 같은 걸 하기도 어렵기 때문에 이러한 불편함을 해소하기 위해 **Promise**가 등장했습니다.

> **Promise**는 비동기 작업이 완료되면 값을 알려주는 객체입니다.

- Pending: 비동기 작업이 끝나기를 기다릴 때
- Fulfilled: 비동기 작업이 성공적으로 끝났을 때, 비동기 작업의 성공 결과를 결괏값으로 갖게 됨.
- Rejected: 비동기 작업이 실패했을 때, 비동기 작업에서 발생한 오류를 결괏값으로 갖게 됨.

Promise는 이렇게 세 가지 상태를 갖고있습니다.

> `async` / `await`문법은 Promise 객체를 다루는 방법 중 하나입니다.

Promise 객체 앞에 `awiat` 키워드를 쓰면 Promise의 상태가 fulfilled 또는 rejected가 될 때까지 기다립니다.

- Fulfilled 상태가 되면 Promise 객체의 결괏값을 리턴
- Rejected 상태가 되면 Promise 객체의 결괏값(error)을 throw합니다.

### 자바스크립트에서 this 키워드의 사용과 특성

- 글로벌: 최상위 혹은 일반적인 함수 내에서 사용, window 오브젝트 등을 가리킴
- 메서드: 오브젝트에 포함된 함수 내에서 사용, 오브젝트를 가리킴
- 생성자(컨스트럭터): 오브젝트를 만드는 함수에서 사용, 생성된 오브젝트 가리킴
- 화살표 함수: 생성된 시점의 this 사용

### 렉시컬 스코프(Lexical Scope)의 개념과 특성

- 스코프라는 것은 함수나 변수와 같이 선언된 것을 엑세스할 수 있는 범위
- 선언될 때 범위를 사용하는 것이 **렉시컬 스코프**임
- **클로져**: 렉시컬 스코프 밖에 변수를 만들면 선언 이후 실행할 때 계속 이용 가능
- 그에 반해 동적 스코프는 스코프가 실행 시점, 환경에 따라 달라짐

### 이벤트 버블링과 캡쳐링을 설명하고 이를 방지하기 위한 방법

- 캡쳐링: 최상위 요소에서 시작해, 이벤트 발생 위치까지 내려가는 과정
- 버블링: 발생 위치에서 상위 요소로 전파되는 과정
- `e.stopPropagation`으로 방지할 수 있다.

### 브라우저가 어떻게 동작하는지 설명

- 브라우저는 웹 페이지 등을 수신하고 탐색하기 위한 소프트웨어
- 최종적으로 웹 페이지를 렌더링하기까지 여러 과정을 거친다.
  1. UI에서 요청을 입력 받고
  2. 서버와 통신해 요청을 보내고 응답을 받고
- 위 과정에서 개입되는 일반적인 구성 요소
  - 브라우저 엔진: 인터페이스의 요청을 수신하고 전반적인 과정을 담당
  - 렌더링 엔진: 콘텐츠 표시. HTML, CSS 해석
  - 자바스크립트 해석기: JS 해석 및 실행
  - UI 백엔드: OS에서 정해진 사용자 인터페이스를 그리는 파트
  - 자료 저장소: 쿠키, 로컬 스토리지 등 담당

### 프로미스(Promise)의 3가지 상태에 대해 설명

- Promise는 자바스크립트에서 비동기 프로그래밍을 할 때 사용한다.
- 미래의 동작을 정의할 수 있으며, 3가지 상태로 미래의 동작을 표현한다.
- Pending
  - 아직 동작이 끝나지 않고, 값도 아직 없음
  - API 응답을 기다리는 등
- Fulfilled
- Rejected

### React에서 컴포넌트란? 함수형 컴포넌트와 클래스 컴포넌트의 차이점

- 컴포넌트란 UI를 구성하는 재사용 가능한 부품과 같은 단위
- 함수형 컴포넌트는 함수로 정의되어 Hook을 사용해 상태 관리, 생명주기 연동 등이 가능해짐
- 클래스 컴포넌트는 클래스 문법으로, 상태와 생명주기를 관리할 수 있는 예전 방식
- 현재는 함수형 컴포넌트로 대부분 대체 가능함

### SSG, SSR, CSR

- CSR: 브라우저에서 모든 렌더링을 수행. 동적인 상호작용이 중요한 웹 어플리케이션에 적합
- SSR: 서버에서 최초 페이지를 완성해서 전송. SEO 최적화, 로딩 속도 개선에 유리. 콘텐츠 중심 웹사이트 혹은 마케팅 사이트에 적합
- SSG: 모든 페이지를 빌드시에 미리 생성해 서버에 파일로 저장. 로딩 속도가 매우 빠름. 변경이 거의 없는 문서 웹사이트 등에 적합

### 리액트에서 Virtual DOM이 무엇인지, 이를 사용하는 이유

- 리액트에서는 선언형으로 전체 UI를 서술해야함
- 렌더링 시 자동적으로 변경을 감지하고 UI를 업데이트해야 하지만, 전달받은 UI 내용이 실제 변경보다 많음
- 비용이 큰 브라우저 렌더링을 피하면서 변경을 감지하기 위해 실제 DOM 대신 가상의 DOM 표현으로 UI를 메모리에 저장
- Virtual DOM을 통해 브라우저 렌더링 (reflow, repaint) 등을 필요한 만큼 최소한으로 수행

### Primary Key 와 Foreign Key

- Primary Key: 한 테이블에서 유일성을 보장하는 한 속성. 식별자로 쓰이기 때문에 이 속성으로 특정 행을 식별할 수 있어야함
- Foreign Key: 다른 테이블의 Primary Key를 참조하기 위한 속성으로 관계형 데이터베이스에서 관계를 설정하는데 사용(일대다 관계 등)

### Prisma의 $transaction에 대해 설명

- DB와 상호작용을 하다 보면 일부만 실행돼서는 안되는 쿼리가 있음 (예: 재고는 감소했지만 주문이 생성되지 않음)
- DB의 transaction을 통해서 atomic하게(원자적) 여러 작업을 수행할 수 있음
- 이 경우, 서버가 오류로 작업이 실패하더라도 rollback이 일어남. all or nothing
- prisma의 $transaction을 이용하면 여러 쿼리를 atomic하게 실행
- Promis.all과 같이 query를 await하지 않고 인자에 배열로 넣음

### 리액트만 사용할 때와 비교해 Next.js를 사용하는 이유에 대해 설명해 주세요.

### 세션 기반 인증과 토큰 기반 인증의 차이점을 설명하세요. 어떤 상황에서 각각을 사용하면 좋을지 예를 들어 설명해주세요.

- 세션 기반 인증 (Stateful, Database-backed)
  - 로그인 상태, 권한 정보 등을 서버의 DB 등에 저장하는 방식
  - 쿠키 등으로 DB의 Rescord ID를 추적하도록 함
  - 세션 무효화 (강제 로그아웃)이 용이
  - 금융 서비스 등 즉각적인 인증 상태 반영이 필요한 곳에서 용이
- 토큰 기반 인증 (Stateless)
  - 로그인 상태, 권한 정보 등을 DB가 아닌 토큰에 검증 가능한 형태로 저장
  - JWT 등을 사용할 수 있음
  - 세션 DB에 대한 엑세스를 줄이는 대신 무효화가 어려울 수 있음
  - 약간의 보안성을 희생하고 대규모 서비스 등을 위한 확장성을 취하는 형태

### RESTful API의 개념과 주요 제약 조건을 설명하세요.

RESTful API의 REST는 Representational State Transfer의 약자로, RESTful API는 클라이언트-서버 구조에서 REST 제약 조건을 따르며 웹 표준(HTTP/URL)을 사용하여 정보를 교환하는 방식입니다.

REST의 주요 제약 조건은 다음과 같습니다:

- Client-Server: 클라이언트와 서버의 역할이 명확하게 분리되어 있어야 하며, 이는 서로의 독립성을 보장하고 인터페이스의 단순화에 기여합니다.
- Stateless: 서버는 클라이언트의 상태 정보를 저장하지 않고, 각 요청을 독립적으로 처리해야 합니다. 이는 서버 설계의 단순성과 확장성을 증가시킵니다.
- Cache: 응답은 캐시 가능해야 하며, 캐싱을 통해 응답성과 효율성을 높일 수 있습니다.
- Uniform Interface
- Layered System
- Code on Demand (optional)

이러한 제약 조건들은 RESTful API 디자인을 통해 더욱 강력하고 유연한 웹 서비스를 개발할 수 있게 하며, 이는 개발자와 최종 사용자 모두에게 큰 이점을 제공합니다.

### Express 애플리케이션에서 미들웨어가 실행되는 순서와 이 순서가 왜 중요한지 설명해주세요.

Express에서 미들웨어는 라우터에 추가된 순서대로 실행됩니다.

이 순서는 요청 처리와 응답 구성에서 결정적인 역할을 합니다. 예를 들어, 보안 미들웨어가 로깅 미들웨어보다 먼저 실행되어야 하므로 안전하지 않은 요청이 기록되기 전에 걸러낼 수 있습니다.

잘못된 순서로 미들웨어를 배치하면

### OAuth 인증 프로세스에 대해 설명해주세요

OAuth 인증 프로세스는 사용자 서비스 제공자(예: 소셜 미디어 플랫폼)를 통해 다른 애플리케이션(에: 써드파티 앱)에 로그인 할 수 있게 해주는 프로세스입니다.

사용자 인증 요청

- 사용자가 써드파티 애플리케이션에서 로그인을 요청하면, 애플리케이션은 리소스 서버(예: Facebook)에 대한 인증 요청을 시작합니다.

OAuth 서버와의 상호작용

- 사용자는 OAuth 서버에 로그인하고, 써드파티 애플리케이션에 특정 데이터에 접근할 수 있는 권한을 부여합니다.

토큰 발급

- 권한 부여 후, OAuth 서버는 써드 파티 애플리케이션에 액세스
